* Singleton
  Singleton Patterns is a creational design pattern that guarantees a class has
  only one instance and provides a global point of access to it.

** Implementation
   A singleton object can be implemented by restricting construction of the
   singleton class by other classes, by making the *constructor private* and
   providing a *public static method* to access the singleton object directly
   from the class.

   .image ./singleton.webp

*** Lazy Initialization

    @code java
    class Singleton {
      private static Singleton instance;

      private Singleton() {}

      public static Singleton getInstance() {
        if (instance == null) instance = new Singleton();
        return instance;
      }
    }
    @end

    - Checks if the instance already exist.
    - If not, it creates a new instance.
    - If an instance already exists, it skips the creation step.

*** Thread-Safe Singleton

    @code java
    class ThreadSafeSingleton {
      private static ThreadSafeSingleton instance;

      private ThreadSafeSingleton() {}

      // Public method to get the instance, with synchronized keyword
      public static synchronized ThreadSafeSingleton getInstance() {
        if (instance == null) {
          instance = new ThreadSafeSingleton();
        }
        return instance;
      }
    }
    @end

    This method achieves thread-safety by making the `getInstance` method
    synchronized.

    The `synchronized` keyword in Java is used to ensure that only one thread
    can execute a particular block of code. This ensures exclusive locking and
    mutual exclusion. If some other thread is waiting for the lock, the OS
    may pause and context switch to another thread.

    The synchronized block of code not only provides mutual exclusion but also
    includes memory visibility guarantee. It does this by flushing its local
    caches so that it sees the most recent values from the main memory before
    entering the synchronized block (acquiring a lock). Just before exiting the
    synchronized block (releasing the lock) any changes made within the block
    are flushed to the main memory, making them visible to all other threads.

*** Double Checked Locking

    @code java
    class DoubleCheckedSingleton {
      // The single instance, initially null, marked as volatile
      private static volatile DoubleCheckedSingleton instance;

      private DoubleCheckedSingleton() {}

      public static DoubleCheckedSingleton getInstance() {
        // First check (not synchronized)
        if (instance == null) {
          // Synchronize on the class object
          synchronized (DoubleCheckedSingleton.class) {
            // Second check (synchronized)
            if (instance == null) {
              instance = new DoubleCheckedSingleton();
            }
          }
        }
        return instance;
      }
    }
    @end

    This singleton class makes its instance volatile, which makes any write to
    the variable flushed to the main memory immediately, making it visible to
    all CPU cores.

    A part of the `getInstance` method is also synchronized which acquires a
    lock on the class object of the class.

